---
title: "Projet R"
author: "Ella Pidoux, Tifaine CATTANEO, Marion VERGNOL, Loris GONZALEZ"
date: "2024-09-10"
output: html_document
---

```{r setup, include=FALSE, warning =FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction 

##Contexte : pourquoi ce script
  Une hausse de la fréquentation des forêts et une sensibilisation accrue des administrés aux enjeux environnementaux implique aujourd'hui, pour le gestionnaire, un changement de gestion. Ce script permet d'adapter les coupes et travaux aux forêts les plus exposées au public, et, à l'échelle de la forêt, d'avoir une gestion différenciée aux abords des routes, parkings et points d'eau. 

##Ce que fait notre script
 Ce script permet de connaître les parkings à 500 M de la forêt. 
A partir de ces parkings, des isochrones ont été tracées pour connaître toutes les villes de plus de 5000 habitants situées à 30 minutes en voiture. Les habitants de ces différentes villes ont été sommées, pour évaluer le nombre de visiteurs potentiels. 
L'impact des routes et des parkings a aussi été pris en compte. 3 zones ont été tracées en fonction de la distance à ces infrastructures. Cela doit permettre au gestionnaire de connaitre les zones les plus exposées au public, mais aussi des connaître les zones du massif où la biodiversité est soumise à des pressions (sonores ou présence de déchets par exemple). 
Des Buffers ont aussi été tracés autour des points d'eau afin de mettre en avant les zones d'intérêt pour le public, devant ainsi faire l'objet d'un traitement particulier. 



``` {r installation et mise à jour des packages }
install.packages(librarian)
librarian::shelf(happign,  # pour les données Web et IGN
                 osmdata,   # pour manipuler les données d'openstreetmap
                 osrm,  # pour manipuler les données d'openstreetmap
                 sf,  # pour manipuler les données vecteurs
                 tmap,  # pour la visualisation des cartes
                 dplyr,  #
                 viridis)  # pour les palettes de couleurs

tmap_mode("view")  # passe en mode interactif pour l'affichage des cartes

```

# Choix de la forêt

  Le gestionnaire public peut choisir la forêt qu'il a à sa charge grâce à mapedit et le périmètre de celle-ci sera généré :
  
```{r choix de la forêt}
point_foret <- mapedit::drawFeatures()
surface_foret <- get_wfs(x = point_foret,
                         layer = "BDTOPO_V3:foret_publique")
```

# Villes de plus 5000 habitants à proximité de la forêt

  Afin d'aider le gestionnaire dans le choix des coupes & travaux à effectuer en forêt, il convient de connaître le nombre de visiteurs potentiels, et ainsi la pression de fréquentation qui en découle. Pour cela, nous avons identifié le nombre d'habitant des communes  alentour. Nous avons ainsi identifié les parkings à 500 M de la forêt grâce à des buffers puis les villes à moins de 30 minutes en voiture, grâce à des isochrones. Le nombre d'habitant provient de données IGN (la carte "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune"). 
Le choix a été fait de garder seulement les villes de plus de 5000 habitants. 

```{r surface de 500m autour de la surface de la forêt}
surface_rech_parking <- st_buffer(surface_foret,
                                500)
bbox_foret <- st_bbox(surface_rech_parking)
query_parking <- opq(bbox = bbox_foret) |>
  add_osm_feature(key = 'amenity',
                  value = c('parking'))

# Création d'une couche vecteur avec les points de parking
osm_parking <- osmdata_sf(query_parking)
parking_sf <- osm_parking$osm_points

# Suppression des points au-delà de la zone de recherche (forêt et 500m autour)
parking_foret <- st_intersection(parking_sf["geometry"],
                                 surface_rech_parking["geometry"])


```

  Les points de parking ont été récupérés sur OpenStreetMap (OSM). Les points de parking ont été récupérés dans la forêt, et autour sur une distance de 500m. En effet, il a été considéré que les visiteurs peuvent laisser leurs véhicules au maximum à cette distance. Néanmoins, le fichier OSM contenait souvent plusieurs points pour un même parking. Il a donc été nécessaire de les regrouper en utilisant la méthode du clustering. 

```{r regroupement des points des parkings}
# Regrouper les points situés à moins de 200m les uns des autres et création
# d'un unique point centroïde pour les nouveaux groupements
dist_parking <- st_is_within_distance(parking_foret, dist = 200)  # Créer les clusters de points proches avec un algorithme de propagation des distances
clusters <- rep(NA, length(dist_parking))  # Créer un vecteur pour les clusters

cluster_id <- 1  # Fonction pour propager l'identifiant de cluster
for (i in seq_along(dist_parking)) {
  if (is.na(clusters[i])) {
    # Assigner un nouvel identifiant de cluster
    clusters[i] <- cluster_id
    # Propager cet identifiant à tous les voisins connectés
    queue <- dist_parking[[i]]
    while (length(queue) > 0) {
      j <- queue[1]
      queue <- queue[-1]
      if (is.na(clusters[j])) {
        clusters[j] <- cluster_id
        queue <- c(queue, dist_parking[[j]])
      }
    }
    cluster_id <- cluster_id + 1
  }
}

parking_foret$cluster_id <- clusters  # Ajouter les clusters au DataFrame

groupe_parking <- parking_foret %>%  # Calculer le centroïde de chaque groupe de points
  group_by(cluster_id) %>%
  summarise(geometry = st_centroid(st_combine(geometry))) %>%
  ungroup()

qtm(groupe_parking)
```

Après avoir récupéré les points des parkings sans doublons, il a été possible d'y appliquer des isochrones pour récupérer toutes les zones autour de la forêt atteignables en moins de 30 minutes en voiture. Il s'agit du temps maximum estimé qu'une famille est prête à faire pour une balade en forêt. A partir du  polygone ainsi tracé, il a été possible de récupérer toutes les villes de plus de 5000 habitants à proximité de la forêt. Ensuite une catégorisation des villes a été faite ; plus la ville a une population élevée, plus elle contient de visiteurs potentiels. 


```{r categorisation villes}
# Calcul des isochrones de 30 min en voiture des parking de la forêt
iso_30 <- osrmIsochrone(groupe_parking["geometry"],
                        breaks = 30,
                        res = 20)

# Récupération des informations des communes dans l'isochrone
commune_iso <- get_wfs(x = iso_30,
                       layer = "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune")

# Sélection des communes de plus de 5000 habitants
commune_5000 <- commune_iso[commune_iso$population >= 5000, ]

# Pression des communes selon le nombre d'habitants 
# Classification des communes en fonction de la population
ptit_commune <- commune_5000[commune_5000$population <= 7000, ]
moy_commune <- commune_5000[commune_5000$population > 7000 & commune_5000$population <= 10000, ]
grde_commune <- commune_5000[commune_5000$population > 10000, ]

# Visualisation de la classification des communes
# (Possibilité de former un buffer autour des limites communales)
pression_commune <- buffer.points(ptit_commune, x = 0, color = "green") +
  buffer.points(moy_commune, x = 0, color = "yellow") +
  buffer.points(grde_commune, x = 0, color = "red")

print(pression_commune)
```

# Identification des infrastructures routières à proximité et à l'intérieur de la forêt

De plus en plus d'infrastructures morcellent la forêt française. Leur utilisation par le grand public attire de nombreux véhicules dans les massifs et à leurs abords. Le gestionnaire doit désormais prendre en compte l'aspect paysager durant ses interventions sylvicoles. Pour cela, des buffers ont été tracés autour des routes pour permettre d'adapter les coupes & travaux en forêt. Les routes ont une importance d'après l'IGN différente de celle utilisée habituellement par l'administration. En effet, l'IGN classifie le système routier selon l'importance du trafic. 
Les buffers font donc des tailles différentes selon la catégorie du tronçon : 
  - importance 1 : liaison entre métropoles. 
  - importance 2 : liaison entre départements.
  - importance 3 : liaison entre communes d'un même département.
  - importance 4 : liaison à l'intérieur d'une commune permettant de se déplacer rapidement. 
  - importance 5 : Autres liaisons circulables. 

L'importance 6 a été laissée de côté étant des sentiers non utilisables par des véhicules motorisés. 

Des fonctions ont été codées afin de faciliter la mise en place des buffers et de leur visualisation. 

```{r fonctions utilisées}
buffer.route.taille <- function(sf, y, x){
  # y = importance ; x = dist
  routes <- subset(sf,
                   sf$importance == y)
  buffer <- st_buffer(routes,
                      dist = x)
  
  if (!is_empty_sf(buffer)) {
    return(buffer)
  } 
}
buffer.taille.couleur <- function(sf, y, x, color){
  # y = importance ; x = dist ; color = couleur
  routes <- subset(sf,
                   sf$importance == y)
  buffer <- st_buffer(routes,
                      dist = x)
  
  if (!is_empty_sf(buffer)) {
    return(tm_shape(buffer) + tm_polygons(col = color))
  } 
}

# Fonction de visulation avec couleur des buffers de routes
buffer.diff.routes <- function(sf) {
  # initialisation de la carte avec les bordures
  map <- tm_shape(surface_foret) + 
    tm_borders(col = 'black')
  
  # ajouter les buffers de taille et couleur différentes
  map <- map + buffer.taille.couleur(sf, 1, 150, 'red')
  map <- map + buffer.taille.couleur(sf, 2, 100, 'orange')
  map <- map + buffer.taille.couleur(sf, 3, 80, 'yellow')
  map <- map + buffer.taille.couleur(sf, 4, 50, 'cyan')
  map <- map + buffer.taille.couleur(sf, 5, 25, 'green')
  
  # afficher la carte
  print(map)
}
```

```{r impact des routes}
# Partie 4 : Pression des routes ----

# Faire nouvelle surface de recherche des routes dans la forêt et à 50m autour
# (pour inclure les routes longeant la forêt sans la pénétrer)
surface_rech_route <- st_buffer(surface_foret,
                                     50)
#surface_rech_route <- st_union(buffer_ptit_perim_foret["geometry"],
#                               surface_foret["geometry"])

# Sélection des routes traversant et longeant la forêt
routes_foret <- get_wfs(surface_rech_route,
                           "BDTOPO_V3:troncon_de_route",
                           spatial_filter = "intersects") 

# Création de buffer selon la nature des routes
route_imp1 <- buffer.route.taille(routes_foret, 1, 150)
route_imp2 <- buffer.route.taille(routes_foret, 2, 110)
route_imp3 <- buffer.route.taille(routes_foret, 3, 100)
route_imp4 <- buffer.route.taille(routes_foret, 4, 80)
route_imp5 <- buffer.route.taille(routes_foret, 5, 50)
route_imp6 <- buffer.route.taille(routes_foret, 6, 25)

# Visualisation de la pression des routes
pression_routes <- buffer.diff.routes(routes_foret)
print(pression_routes)
```

# Pression du grand public autour des parkings

  Après avoir visualisé l'importance des routes pour le gestionnaire dans sa gestion du paysage forestier, il est nécessaire de prendre en considération l'impact des parkings dans les actions de gestion. En effet, autour de ces parkings dans un rayon plus ou moins large, la fréquentation des visiteurs peu générer des installations pour l'accueil du public ou des adaptations dans le déroulé des interventions sylvicoles. 
Il a été considéré qu'une pression plus forte se fait sur un rayon de 500 m autour du parking, une pression moins élevée ensuite sur les 250m suivant. 

```{r pression parking}
# Fonction qui crée les buffers de pression cumulés
pression.buffer <- function(sf){
  grde_pression <- st_buffer(sf, 500)
  moy_pression <- st_buffer(grde_pression, 250)
  ptit_pression <- st_buffer(moy_pression, 250)
  return(list(
    grde_pression = grde_pression,
    moy_pression = moy_pression,
    ptit_pression = ptit_pression
  ))
}

# Buffer de pression du grand public autour des parkings 
pression_gp_parking <- pression.buffer(groupe_parking)

# Accéder aux buffers de pression des parking
grde_pression_parking_sf <- pression_gp_parking$grde_pression
moy_pression_parking_sf <- pression_gp_parking$moy_pression
ptit_pression_parking_sf <- pression_gp_parking$ptit_pression

# Visualisation des buffers parking
map <- tm_shape(surface_foret) + 
  tm_borders(col = 'black')
map <- map + tm_shape(ptit_pression_parking_sf) + tm_polygons(col = 'green')
map <- map + tm_shape(moy_pression_parking_sf) + tm_polygons(col = 'orange')
map <- map + tm_shape(grde_pression_parking_sf) + tm_polygons(col = 'red')
print(map)
```

# visualisation des sentiers

  Pour pouvoir gérer l'affluence en forêt et identifier les zones exposées au public, le tracé des sentiers a été récupéré à partir de la "BDTOPO_V3:troncon_de_route". Cela permet là encore au gestionnaire d'identifier les zones exposées à la vue du public, et d'adapter les coupes et travaux en conséquence. 

```{r fréquentation des chemins}

# Pression sur les chemins aux abords des parking
troncons <- get_wfs( x = surface_foret,
                     layer = "BDTOPO_V3:troncon_de_route",
                     spatial_filter = "intersects")

chemin_foret <- troncons[troncons$nature %in% c("Sentier",
                                                "Chemin",
                                                "Route empierrée"), ]

chemin_freq <- st_intersection(chemin_foret["geometry"],
                                   pression_gp_parking$ptit_pression["geometry"])

# Visualisation des chemins les plus fréquentés

qtm(chemin_freq)
```

# visualisation des points d'eau 

```{r visualisation point d'eau}
query_water <- opq(bbox = bbox_foret) |>
  add_osm_feature(key = 'water',
                  value = c('river',  # rivière
                            'oxbox',  # méandre
                            'canal',  # canal
                            'ditch',  # fossé
                            'lake',  # lac
                            'reservoir',  # lac artificiel
                            'pond',  # petit lac artificiel
                            'stream_pool'))  # petite gorge

query_waterway <- opq(bbox = bbox_foret) |>
  add_osm_feature(key = 'waterway',
                  value = c('stream',  # ruisseau
                            'watefall'))  # cascade

query_natural <- opq(bbox = bbox_foret) |>
  add_osm_feature(key = 'natural',
                  value = c('water'))  # masse d'eau naturelle

# Fusion des éléments eau obtenus avec les  key différentes
all_eau <- c(osmdata_sf(query_water),
             osmdata_sf(query_waterway),
             osmdata_sf(query_natural))

# Création d'une couche vecteur selon la nature des éléments eau
all_eau_points_sf <- all_eau$osm_points
all_eau_lignes_sf <- all_eau$osm_lines
all_eau_polygones_sf <- all_eau$osm_polygons

#Sélection des éléments eau dans la forêt et à 1km autour des parking
all_eau_points_foret <- st_intersection(all_eau_points_sf["geometry"],
                                        surface_foret["geometry"])
all_eau_points_parking <- st_intersection(all_eau_points_foret["geometry"],
                                        pression_gp_parking$ptit_pression["geometry"])

all_eau_lignes_foret <- st_intersection(all_eau_lignes_sf["geometry"],
                                        surface_foret["geometry"])
all_eau_lignes_parking <- st_intersection(all_eau_lignes_foret["geometry"],
                                          pression_gp_parking$ptit_pression["geometry"])

all_eau_polygones_foret <- st_intersection(all_eau_polygones_sf["geometry"],
                                           surface_foret["geometry"])
all_eau_polygones_parking <- st_intersection(all_eau_polygones_foret["geometry"],
                                          pression_gp_parking$ptit_pression["geometry"])

#Visualisation des différents éléments eau à moins d'1km des parking
qtm(all_eau_points_parking)
qtm(all_eau_lignes_parking)
qtm(all_eau_polygones_parking)
```

